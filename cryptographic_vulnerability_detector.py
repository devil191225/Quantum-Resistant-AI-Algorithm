import numpy as np
import tensorflow as tf
from tensorflow import keras
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from collections import Counter

class NetworkCryptoDetector:
    def __init__(self):
        self.model = None
        self.scaler = StandardScaler()
        self.feature_names = None
        self.vulnerability_categories = [
            'deprecated_algorithms', 
            'implementation_flaws',
            'protocol_downgrades',
            'quantum_vulnerable_exchange',
            'weak_parameters'
        ]
    
    def generate_synthetic_traffic_data(self, num_samples=10000):

        protocols = ['TLS 1.0', 'TLS 1.1', 'TLS 1.2', 'TLS 1.3', 'SSL 3.0']
        cipher_suites = [
            'TLS_RSA_WITH_AES_128_CBC_SHA', 
            'TLS_RSA_WITH_AES_256_CBC_SHA',
            'TLS_RSA_WITH_3DES_EDE_CBC_SHA',
            'TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256',
            'TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384',
            'TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256',
            'TLS_AES_128_GCM_SHA256',
            'TLS_AES_256_GCM_SHA384',
            'TLS_CHACHA20_POLY1305_SHA256',
            'TLS_RSA_WITH_RC4_128_SHA'
        ]
        key_exchange = ['RSA', 'DHE', 'ECDHE', 'DH', 'ECDH']
        curves = ['P-256', 'P-384', 'P-521', 'X25519', 'X448', 'secp256k1']
        signature_algorithms = ['RSA-SHA1', 'RSA-SHA256', 'ECDSA-SHA256', 'RSA-PSS-SHA256', 'ED25519']
        
        data = []
        
        for _ in range(num_samples):
            protocol = np.random.choice(protocols, p=[0.1, 0.1, 0.4, 0.3, 0.1])
            cipher_suite = np.random.choice(cipher_suites)
            key_exch = np.random.choice(key_exchange)
            curve = np.random.choice(curves)
            sig_alg = np.random.choice(signature_algorithms)
            
            dh_param_size = np.random.choice([512, 1024, 2048, 3072, 4096])
            cert_key_size = np.random.choice([1024, 2048, 3072, 4096])
            cert_signature = np.random.choice(['sha1WithRSAEncryption', 'sha256WithRSAEncryption', 'ecdsa-with-SHA256'])
            cert_validity_days = np.random.randint(1, 825)
            session_resumed = np.random.choice([0, 1], p=[0.7, 0.3])
            packet_count = np.random.randint(5, 100)
            data_volume = np.random.randint(500, 100000)
            avg_packet_size = np.random.randint(100, 1500)
            record = {
                'protocol': protocol,
                'cipher_suite': cipher_suite,
                'key_exchange': key_exch,
                'curve': curve,
                'signature_algorithm': sig_alg,
                'dh_param_size': dh_param_size,
                'cert_key_size': cert_key_size,
                'cert_signature': cert_signature,
                'cert_validity_days': cert_validity_days,
                'session_resumed': session_resumed,
                'packet_count': packet_count,
                'data_volume': data_volume,
                'avg_packet_size': avg_packet_size
            }
            
            vulnerabilities = {
                'deprecated_algorithms': 0,
                'implementation_flaws': 0,
                'protocol_downgrades': 0,
                'quantum_vulnerable_exchange': 0,
                'weak_parameters': 0
            }
            
            if protocol in ['SSL 3.0', 'TLS 1.0']:
                vulnerabilities['deprecated_algorithms'] = 1
            
            if 'RC4' in cipher_suite or '3DES' in cipher_suite:
                vulnerabilities['deprecated_algorithms'] = 1
                
            if 'SHA1' in sig_alg or 'SHA1' in cert_signature:
                vulnerabilities['deprecated_algorithms'] = 1

            if (protocol == 'TLS 1.2' and 'RSA' in cipher_suite and
                cert_key_size < 2048 and np.random.random() < 0.7):
                vulnerabilities['implementation_flaws'] = 1
            if protocol in ['TLS 1.0', 'TLS 1.1'] and np.random.random() < 0.4:
                vulnerabilities['protocol_downgrades'] = 1
            if key_exch == 'RSA' or key_exch == 'DH' or key_exch == 'ECDH':
                vulnerabilities['quantum_vulnerable_exchange'] = 1
            if dh_param_size < 2048 or cert_key_size < 2048:
                vulnerabilities['weak_parameters'] = 1
            record.update(vulnerabilities)
            data.append(record)
        df = pd.DataFrame(data)
        
        print(f"Generated {len(df)} synthetic network traffic samples")
        print("Vulnerability distribution:")
        for vuln in self.vulnerability_categories:
            count = df[vuln].sum()
            percent = count / len(df) * 100
            print(f"  {vuln}: {count} samples ({percent:.1f}%)")
        
        return df
    
    def preprocess_data(self, df):
        categorical_features = ['protocol', 'cipher_suite', 'key_exchange','curve', 'signature_algorithm', 'cert_signature']
        
        df_encoded = pd.get_dummies(df, columns=categorical_features)
        X = df_encoded.drop(self.vulnerability_categories, axis=1)
        y = df_encoded[self.vulnerability_categories]       
        self.feature_names = X.columns.tolist()      
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        X_train = self.scaler.fit_transform(X_train)
        X_test = self.scaler.transform(X_test)
        return X_train, X_test, y_train, y_test
    
    def build_model(self, input_shape):
        model = keras.Sequential([
            keras.layers.Input(shape=(input_shape,)),
            keras.layers.Dense(64, activation='relu'),
            keras.layers.BatchNormalization(),
            keras.layers.Dropout(0.3),
            keras.layers.Dense(32, activation='relu'),
            keras.layers.BatchNormalization(),
            keras.layers.Dropout(0.2),
            keras.layers.Dense(len(self.vulnerability_categories), activation='sigmoid')
        ])
        
        model.compile(
            optimizer='adam',
            loss='binary_crossentropy',
            metrics=['accuracy', keras.metrics.AUC(name='auc')]
        )
        
        return model
    
    def train(self, epochs=20, batch_size=32, use_synthetic_data=True, data=None):

        if use_synthetic_data:
            print("Generating synthetic network traffic data...")
            df = self.generate_synthetic_traffic_data()
        else:
            if data is None:
                raise ValueError("External data must be provided when use_synthetic_data=False")
            df = data
        X_train, X_test, y_train, y_test = self.preprocess_data(df)
        self.model = self.build_model(X_train.shape[1])
        print("Training vulnerability detection model...")
        history = self.model.fit(
            X_train, y_train,
            epochs=epochs,
            batch_size=batch_size,
            validation_data=(X_test, y_test),
            verbose=1
        )
        
        self.evaluate(X_test, y_test)
        
        return history
    
    def evaluate(self, X_test, y_test):
      
        if self.model is None:
            print("Model hasn't been trained yet")
            return
        
        y_pred = self.model.predict(X_test)
        y_pred_binary = (y_pred > 0.5).astype(int)
        
        print("\nModel Evaluation:")
        for i, category in enumerate(self.vulnerability_categories):
            true_positives = np.sum((y_test.iloc[:, i] == 1) & (y_pred_binary[:, i] == 1))
            false_positives = np.sum((y_test.iloc[:, i] == 0) & (y_pred_binary[:, i] == 1))
            true_negatives = np.sum((y_test.iloc[:, i] == 0) & (y_pred_binary[:, i] == 0))
            false_negatives = np.sum((y_test.iloc[:, i] == 1) & (y_pred_binary[:, i] == 0))
            
            accuracy = (true_positives + true_negatives) / (true_positives + true_negatives + false_positives + false_negatives)
            precision = true_positives / (true_positives + false_positives) if (true_positives + false_positives) > 0 else 0
            recall = true_positives / (true_positives + false_negatives) if (true_positives + false_negatives) > 0 else 0
            f1 = 2 * precision * recall / (precision + recall) if (precision + recall) > 0 else 0
            
            print(f"\n{category}:")
            print(f"  Accuracy: {accuracy:.4f}")
            print(f"  Precision: {precision:.4f}")
            print(f"  Recall: {recall:.4f}")
            print(f"  F1 Score: {f1:.4f}")
            print(f"  False Positive Rate: {false_positives/(false_positives+true_negatives):.4f}")
    
    def analyze_traffic(self, traffic_data):
       
        if self.model is None:
            raise ValueError("Model hasn't been trained yet")
        
        categorical_features = ['protocol', 'cipher_suite', 'key_exchange', 
                             'curve', 'signature_algorithm', 'cert_signature']
        
        df_encoded = pd.get_dummies(traffic_data, columns=categorical_features)
        for feature in self.feature_names:
            if feature not in df_encoded.columns:
                df_encoded[feature] = 0
        X = df_encoded[self.feature_names]
        X_scaled = self.scaler.transform(X)
        predictions = self.model.predict(X_scaled)
        result = traffic_data.copy()
        for i, category in enumerate(self.vulnerability_categories):
            result[f"{category}_prob"] = predictions[:, i]
            result[f"{category}_detected"] = (predictions[:, i] > 0.5).astype(int)
        result['overall_vulnerability'] = predictions.mean(axis=1)
        
        return result
    
    def generate_alert(self, traffic_analysis, threshold=0.5):
       
        alerts = []
        
        for idx, row in traffic_analysis.iterrows():
            vuln_probs = [row[f"{cat}_prob"] for cat in self.vulnerability_categories]
            if any(prob > threshold for prob in vuln_probs):
                
                alert = {
                    'id': idx,
                    'timestamp': pd.Timestamp.now(),
                    'protocol': row['protocol'],
                    'cipher_suite': row['cipher_suite'],
                    'key_exchange': row['key_exchange'],
                    'detected_vulnerabilities': []
                }
                for category in self.vulnerability_categories:
                    if row[f"{category}_prob"] > threshold:
                        alert['detected_vulnerabilities'].append({
                            'type': category,
                            'confidence': row[f"{category}_prob"]
                        })
                
                max_prob = max(vuln_probs)
                if max_prob > 0.8:
                    severity = "Critical"
                elif max_prob > 0.6:
                    severity = "High"
                elif max_prob > 0.4:
                    severity = "Medium"
                else:
                    severity = "Low"
                
                alert['severity'] = severity
                
                alert['recommended_actions'] = self.generate_recommendations(row)
                
                alerts.append(alert)
        
        return alerts
    
    def generate_recommendations(self, traffic_row):
        recommendations = []
        if traffic_row.get('deprecated_algorithms_detected', 0) == 1:
            if traffic_row['protocol'] in ['SSL 3.0', 'TLS 1.0', 'TLS 1.1']:
                recommendations.append("Upgrade to TLS 1.2 or TLS 1.3")
            
            if 'RC4' in traffic_row['cipher_suite'] or '3DES' in traffic_row['cipher_suite']:
                recommendations.append("Replace deprecated cipher suites with AES-GCM or ChaCha20-Poly1305")
            
            if 'SHA1' in traffic_row['signature_algorithm'] or 'SHA1' in str(traffic_row.get('cert_signature', '')):
                recommendations.append("Replace SHA-1 with SHA-256 or stronger")
        if traffic_row.get('quantum_vulnerable_exchange_detected', 0) == 1:
            recommendations.append("Implement quantum-resistant key exchange algorithms")
        if traffic_row.get('weak_parameters_detected', 0) == 1:
            if traffic_row.get('dh_param_size', 0) < 2048:
                recommendations.append("Increase DH parameters to at least 2048 bits")
            
            if traffic_row.get('cert_key_size', 0) < 2048:
                recommendations.append("Increase certificate key size to at least 2048 bits")
        if not recommendations:
            recommendations.append("Review cryptographic implementation for potential issues")
        
        return recommendations
    
    def plot_training_history(self, history):
    
        plt.figure(figsize=(15, 5))
        plt.subplot(1, 3, 1)
        plt.plot(history.history['accuracy'])
        plt.plot(history.history['val_accuracy'])
        plt.title('Model Accuracy')
        plt.ylabel('Accuracy')
        plt.xlabel('Epoch')
        plt.legend(['Train', 'Validation'], loc='upper left')
        plt.subplot(1, 3, 2)
        plt.plot(history.history['loss'])
        plt.plot(history.history['val_loss'])
        plt.title('Model Loss')
        plt.ylabel('Loss')
        plt.xlabel('Epoch')
        plt.legend(['Train', 'Validation'], loc='upper left')
        plt.subplot(1, 3, 3)
        plt.plot(history.history['auc'])
        plt.plot(history.history['val_auc'])
        plt.title('Model AUC')
        plt.ylabel('AUC')
        plt.xlabel('Epoch')
        plt.legend(['Train', 'Validation'], loc='upper left')
        
        plt.tight_layout()
        plt.show()
    
    def plot_vulnerability_distribution(self, analysis_results):
       
        vuln_counts = {}
        for category in self.vulnerability_categories:
            vuln_counts[category] = analysis_results[f"{category}_detected"].sum()
        
        plt.figure(figsize=(10, 6))
        plt.bar(vuln_counts.keys(), vuln_counts.values())
        plt.title('Detected Vulnerabilities by Category')
        plt.xlabel('Vulnerability Category')
        plt.ylabel('Number of Detections')
        plt.xticks(rotation=45, ha='right')
        plt.tight_layout()
        plt.show()
        severity_counts = Counter(alert['severity'] for alert in 
                                 self.generate_alert(analysis_results))
        
        plt.figure(figsize=(8, 8))
        plt.pie(severity_counts.values(), labels=severity_counts.keys(), 
               autopct='%1.1f%%', startangle=90, colors=['red', 'orange', 'yellow', 'green'])
        plt.title('Alert Severity Distribution')
        plt.axis('equal')
        plt.show()

if __name__ == "__main__":
    detector = NetworkCryptoDetector()
    history = detector.train(epochs=10, batch_size=32)
    detector.plot_training_history(history)
    
    test_traffic = detector.generate_synthetic_traffic_data(num_samples=100)
    analysis = detector.analyze_traffic(test_traffic)
    
    alerts = detector.generate_alert(analysis)
    print(f"\nGenerated {len(alerts)} alerts from {len(test_traffic)} traffic samples")
    
    if alerts:
        print("\nSample Alert:")
        sample_alert = alerts[0]
        print(f"Severity: {sample_alert['severity']}")
        print("Detected Vulnerabilities:")
        for vuln in sample_alert['detected_vulnerabilities']:
            print(f"  - {vuln['type']} (confidence: {vuln['confidence']:.2f})")
        print("Recommended Actions:")
        for action in sample_alert['recommended_actions']:
            print(f"  - {action}")
    
    detector.plot_vulnerability_distribution(analysis)